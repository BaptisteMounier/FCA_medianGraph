\chapter{Contribution}

\section{Implémentation}

Le stage s'est déroulé en deux phases. La première consistait à implémenter la méthode détaillé dans la section précédente afin de la tester sur des cas de façon automatique. La seconde partie du stage avait pour but d'améliorer la méthode afin de prendre en compte le problème de fusion des n\oe uds. Avec en parallèle un renforcement de la compréhension du domaine à travers des articles sur l'existant et des discussions avec l'équipe.

\bigbreak

La toute première question à se poser pour l'implémentation est celle du langage. Le problème n'ayant pas de contraintes particulières je suis partis sur un programme orienté objet en Python. C'est un langage assez répandu et très malléable, ce qui fait de lui un choix basique mais fiable. Choix également renforcé par mon expérience principalement tournée sur du langage objet permettant de m'adapter plus facilement. Une fois ce choix fait, le plus long a été d'adapter l'algorithme pour sa mise en fonction, cela m'a également permis de comprendre de mieux en mieux les mécanismes mis en jeu. À ce stade nous obtenons le workflow en figure \ref{workflow_1}. Le programme commence par effectuer l'importation des données d'entrée. Il extrait un contexte pour chaque treillis formé par les filtres des atomes et effectue l'algorithme vu précédemment en figure \ref{algo_cla}. Une fois fait, le programme regroupe les contextes en un unique et exporte le résultat sous forme graphique à l'aide de Graphviz\cite{doc_graphviz} à travers sa bibliothèque\cite{doc_python_graphviz}. De plus nous effectuons une exportation sous forme de matrice binaire pour ConExp\cite{conexp}, une application permettant de générer les treillis. Nous avons toujours dans cet état le problème sur les cas non triviaux développé plus tôt.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 0.5cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [inout, right = of start] (end) {fin};
			\node [block, below = of start] (import) {importation};
			\node [block, right = of import] (export) {exportation};
			\node [block, below = of import] (extract) {extraction};
			\node [block, right = of extract] (commun) {remise en commun};
			\node [block, below = of extract] (algo) {algorithme};
			% Draw edges
			\path [line2] (start) -- (import);
			\path [line2] (export) -- (end);
			\path [line2] (import) -- (extract);
			\path [line2] (extract) -- (algo);
			\path [line2] (commun) -- (export);
			\path [line2] (algo) -| (commun);
		\end{tikzpicture}
	\end{center}
	\caption{Worflow de la première version du programme}
	\label{workflow_1}
\end{figure}

Il est question à présent de la fusion des n\oe uds dans le but d'obtenir le treillis et des conditions de cette fusion pour en ressortir des règles de fusions. Nous allons nous baser sur le cas mis en avant dans \cite{cla2018} avec en figure \ref{cas_cla_base} le treillis de départ. La figure \ref{cas_cla_obtenu} est un rappel du résultat dans l'état actuel et la figure \ref{cas_cla_desiree} est le résultat optimal. On remarque que les points noirs 10 et 12 du résultat obtenu peuvent ne faire qu'un pour obtenir le point 8 du résultat désiré. En regardant également le treillis distributif maximum en figure \ref{cas_cla_max} on a l'intuition qu'il suffit de remplacer les points qu'on souhaite fusionner par leur supremum, cela à été notre point de départ.

\begin{figure}[H]
	\begin{minipage}{0.5\textwidth}
		\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=left:{1}] (1) at (-0.5, 0.5) {};
			\node [wnode, label=right:{4}] (4) at (0.5, 0.5) {};			
			\node [wnode, label=left:{2}] (2) at (-1, 1) {};
			\node [wnode, label=left:{3}] (3) at (-1, 1.5) {};			
			\node [wnode, label=right:{5}] (5) at (1, 1) {};
			\node [wnode, label=right:{6}] (6) at (1, 1.5) {};			
			\node [wnode, label=right:{7}] (7) at (0, 1) {};			
			\node [wnode, label={$\top$}] (top) at (0, 2) {};
			
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (4);			
			\path [line] (1) -- (2);
			\path [line] (1) -- (7);
			\path [line] (2) -- (3);
			\path [line] (3) -- (top);			
			\path [line] (4) -- (5);
			\path [line] (4) -- (7);
			\path [line] (5) -- (6);
			\path [line] (6) -- (top);			
			\path [line] (7) -- (top);
		\end{tikzpicture}
		\end{center}
		\caption{Treillis de départ}
		\label{cas_cla_base}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=left:{1}] (1) at (-0.5, 0.5) {};
			\node [wnode, label=right:{4}] (4) at (0.5, 0.5) {};			
			\node [wnode, label=left:{2}] (2) at (-1, 1) {};
			\node [wnode, label=left:{3}] (3) at (-1, 1.5) {};			
			\node [wnode, label=right:{5}] (5) at (1, 1) {};
			\node [wnode, label=right:{6}] (6) at (1, 1.5) {};			
			\node [bnode, label=right:{7}] (7) at (0, 1) {};
			\node [bnode, label=left:{10}] (10) at (-0.25, 1.5) {};
			\node [bnode, label=right:{12}] (12) at (0.25, 1.5) {};			
			\node [wnode, label={$\top$}] (top) at (0, 2) {};
			
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (4);			
			\path [line] (1) -- (2);
			\path [line] (1) -- (7);
			\path [line] (2) -- (3);
			\path [line] (3) -- (top);			
			\path [line] (4) -- (5);
			\path [line] (4) -- (7);
			\path [line] (5) -- (6);
			\path [line] (6) -- (top);			
			\path [line] (7) -- (10);
			\path [line] (7) -- (12);
			\path [line] (10) -- (top);
			\path [line] (12) -- (top);			
			\path [line] (2) -- (10);
			\path [line] (5) -- (12);
		\end{tikzpicture}
		\end{center}
		\caption{Treillis obtenu}
		\label{cas_cla_obtenu}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\begin{center}
			\begin{tikzpicture}
				\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
				\node [wnode, label=left:{1}] (1) at (-0.5, 0.5) {};
				\node [wnode, label=right:{4}] (4) at (0.5, 0.5) {};
				\node [wnode, label=left:{2}] (2) at (-1, 1) {};
				\node [wnode, label=left:{3}] (3) at (-1, 1.5) {};
				\node [wnode, label=right:{5}] (5) at (1, 1) {};
				\node [wnode, label=right:{6}] (6) at (1, 1.5) {};
				\node [bnode, label=right:{7}] (7) at (0, 1) {};
				\node [bnode, label=right:{8}] (8) at (0, 1.5) {};
				\node [wnode, label={$\top$}] (top) at (0, 2) {};
		
				\path [line] (bot) -- (1);
				\path [line] (bot) -- (4);
				\path [line] (1) -- (2);
				\path [line] (1) -- (7);
				\path [line] (2) -- (3);
				\path [line] (3) -- (top);
				\path [line] (4) -- (5);
				\path [line] (4) -- (7);
				\path [line] (5) -- (6);
				\path [line] (6) -- (top);
				\path [line] (7) -- (8);
				\path [line] (8) -- (top);
				\path [line] (2) -- (8);
				\path [line] (5) -- (8);
			\end{tikzpicture}
		\end{center}
		\caption{Treillis désirée}
		\label{cas_cla_desiree}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
		\begin{center}
			\begin{tikzpicture}
				\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
				\node [wnode, label=left:{1}] (1) at (-0.5, 0.5) {};
				\node [wnode, label=left:{2}] (2) at (-1, 1) {};
				\node [wnode, label=left:{3}] (3) at (-1.5, 1.5) {};
				\node [wnode, label=right:{4}] (4) at (0.5, 0.5) {};
				\node [wnode, label=right:{5}] (5) at (1, 1) {};
				\node [wnode, label=right:{6}] (6) at (1.5, 1.5) {};
				\node [bnode, label=right:{7}] (7) at (0, 1) {};
				\node [bnode, label=left:{10}] (10) at (-0.5, 1.5) {};
				\node [wnode, label=right:{}] (11) at (-1, 2) {};
				\node [bnode, label=right:{12}] (12) at (0.5, 1.5) {};
				\node [bnode, label=right:{8}] (8) at (0, 2) {};
				\node [wnode, label=right:{}] (13) at (-0.5, 2.5) {};
				\node [wnode, label=right:{}] (14) at (1, 2) {};
				\node [wnode, label=right:{}] (15) at (0.5, 2.5) {};
				\node [wnode, label={$\top$}] (top) at (0, 3) {};
		
				\path [line] (bot) -- (1);
				\path [line] (bot) -- (4);
				\path [line] (1) -- (2);
				\path [line] (1) -- (7);
				\path [line] (2) -- (3);
				\path [line] (2) -- (10);
				\path [line] (3) -- (11);
				\path [line] (4) -- (5);
				\path [line] (4) -- (7);
				\path [line] (5) -- (6);
				\path [line] (5) -- (12);
				\path [line] (6) -- (14);
				\path [line] (7) -- (10);
				\path [line] (7) -- (12);
				\path [line] (8) -- (13);
				\path [line] (8) -- (15);
				\path [line] (10) -- (8);
				\path [line] (10) -- (11);
				\path [line] (11) -- (13);
				\path [line] (12) -- (8);
				\path [line] (12) -- (14);
				\path [line] (13) -- (top);
				\path [line] (14) -- (15);
				\path [line] (15) -- (top);
			\end{tikzpicture}
		\end{center}
		\caption{Treillis distributif maximum}
		\label{cas_cla_max}
	\end{minipage}
\end{figure}

Nous avons ensuite travaillé sur cette piste à partir de toute une série de treillis qui se trouve en annexe \ref{exemplescas} ayant chacun ses spécificités. À chaque résultat déviant du résultat souhaité sur l'un des cas, nous avons effectué un ajustement des conditions de fusion des n\oe uds tout en vérifiant le bon fonctionnement sur les cas déjà traités. Nous sommes arrivés à trois conditions.

\begin{definition}[Conditions de fusion]
Soit $a$ et $b$ les deux n\oe uds à fusionner, le contexte actuel $C(J, M, I)$, le contexte de départ $C_o(J_o, M_o, I_o)$ et $X$ l'ensemble des atomes de $C$ :
\begin{itemize}
	\item Les deux n\oe uds à fusionner ne doivent pas faire partis des n\oe uds du treillis de départ.\\
	$a, b \in J \setminus J_o : a \neq b$
	\item Les deux n\oe uds à fusionner doivent être en couverture d'un n\oe ud présent dans au moins deux filtres d'atomes.\\
	$Pour (x_1, x_2 \in X$ avec $x_1 \neq x_2)$, $\exists c \in J : a' \subseteq c' \subseteq x_1'$ et $b' \subseteq c' \subseteq x_2'$
	\item Les deux n\oe uds à fusionner ne doivent pas avoir de n\oe uds en commun dans leurs idéaux une fois que les idéaux du n\oe ud en commun (celui dont il est question dans la condition précédente) leur sont retirés.\\
	$(\downarrow \! a$ $\cap \downarrow \! b) \setminus \downarrow \! c = \emptyset$
\end{itemize}
\end{definition}

Nous pouvons l'illustrer sur les figures précédentes. Les n\oe uds 10 et 12 de la figure \ref{cas_cla_obtenu} ne sont pas présent dans la figure \ref{cas_cla_base}, ils ne font donc pas partis du treillis de départ. Ces deux n\oe uds sont également en couverture du n\oe ud 7 qui est présent dans les filtres de l'atome 1 et de l'atome 4. Et pour finir, nous avons $\downarrow \! 10$ $\cap \downarrow \! 12 = {7, 1, 4, \bot}$ et $\downarrow \! 7 = {7, 1, 4, \bot}$ donc $(\downarrow \! 10$ $\cap \downarrow \! 12) \setminus \downarrow \! 7 = \emptyset$.

\bigbreak

Avec la mise en place de cette fusion des n\oe uds, nous obtenons un nouveau workflow détaillé en figures \ref{workflow_2} et \ref{workflow_algo}.

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 0.5cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [inout, right = of start] (end) {fin};
			\node [block, below = of start] (import) {importation};
			\node [block, right = of import] (export) {exportation};
			\node [block, below = of import] (extract) {extraction};
			\node [block, right = of extract] (fusion) {fusion};
			\node [block, below = of extract] (algo) {algorithme};
			\node [block, right = of algo] (commun) {remise en commun};
			% Draw edges
			\path [line2] (start) -- (import);
			\path [line2] (export) -- (end);
			\path [line2] (import) -- (extract);
			\path [line2] (extract) -- (algo);
			\path [line2] (fusion) -- (export);
			\path [line2] (algo) -- (commun);
			\path [line2] (commun) -- (fusion);
		\end{tikzpicture}
	\end{center}
	\caption{Worflow de la seconde version du programme, avec la fusion des n\oe uds}
	\label{workflow_2}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 0.5cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [inout, right = of start] (end) {fin};
			\node [algorithm, below = of end] (eachatom) {pour chaque atome};
			\node [block, right = of eachatom] (extract) {extraction};
			\node [block, below = of eachatom] (assemble) {assemblage};
			\node [block, right = of assemble] (distrib) {distributivité};
			% Draw edges
			\path [line2] (start) |- (eachatom);
			\path [line2] (eachatom) -- (end);
			\path [line2] (eachatom) -- (extract);
			\path [line2] (extract) -- (distrib);
			\path [line2] (assemble) -- (eachatom);
			\path [line2] (distrib) -- (assemble);
		\end{tikzpicture}
	\end{center}
	\caption{Sous worflow correspondant au bloque \guillemotleft{} algorithme \guillemotright{}}
	\label{workflow_algo}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 1cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [inout, right = of start] (end) {fin};
			\node [algorithm, below = of end] (each_concept) {pour chaque concept};
			\node [decision, right = of each_concept] (multiple_atoms) {$\in$ filtres de plusieurs atomes ?};
			\node [decision, right = of multiple_atoms] (multiple_sups) {couverture non présente dans la base ?};
			\node [decision, above = of multiple_sups] (unique_sup_inf) {max 1 sup and strict 1 inf?};
			\node [block, left = of unique_sup_inf] (merge_inf) {merge with inf};
			\node [decision, below = of multiple_atoms] (different_atom) {tuple in different atoms source?};
			\node [algorithm, right = of different_atom] (each_tuples) {for each tuple in sups};
			\node [block, left = of different_atom] (merge) {merge tuple};
			% Draw edges
			\path [line2] (start) |- (each_concept);
			\path [line2] (each_concept) -- (end);
			\path [line2] (each_concept) --  node {loop}(multiple_atoms);
			\path [line2] (multiple_atoms) --  node [very near start] {yes}(multiple_sups);
			\path [line2] (multiple_atoms.south) -| node [very near start] {no}(each_concept);
			\path [line2] (multiple_sups) --  node [near start] {yes}(each_tuples);
			\path [line2] (multiple_sups) -- node [near start] {no}(unique_sup_inf);
			\path [line2] (unique_sup_inf) -- node {yes}(merge_inf);
			\path [line2] (unique_sup_inf) -- node [very near start] {no}(each_concept.40);
			\path [line2] (merge_inf) -- (each_concept);
			\path [line2] (each_tuples) -- (each_concept);
			\path [line2] (each_tuples) -- node {loop}(different_atom);
			\path [line2] (different_atom) --  node [near start] {yes}(merge);
			\path [line2] (different_atom.south) -| node [very near start] {no}(each_tuples);
			\path [line2] (merge.130) --  (each_concept.230);
		\end{tikzpicture}
	\end{center}
	\caption{Sous worflow correspondant au bloque \guillemotleft{} fusion \guillemotright{}}
	\label{workflow_algo}
\end{figure}

\section{Problèmes et difficultés}

Nous avons rencontré un problème qui porte sur des cas où un passage complet de la méthode avec post traitement de fusion ne suffit pas, ce cas est présenté sur la figure \ref{clav7_1}. La fusion recréant une situation avec des treillis d'atomes non distributif et demandant donc de refaire un passage dans tout le processus.

\begin{figure}[H]
	\begin{minipage}{0.5\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [bnode, label=right:{1}] (1) at (1, 1) {};
			\node [wnode, label=left:{2}] (2) at (-1, 1) {};
			\node [bnode, label=right:{3}] (3) at (0, 2) {};
			\node [bnode, label=right:{4}] (4) at (2, 2) {};
			\node [wnode, label=left:{5}] (5) at (-2, 2) {};
			\node [bnode, label=right:{6}] (6) at (2, 3) {};
			\node [bnode, label={$\top$}] (top) at (0, 4) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (4);
			\path [line] (2) -- (3);
			\path [line] (2) -- (5);
			\path [line] (4) -- (6);
			\path [line] (6) -- (top);
			\path [line] (3) -- (top);
			\path [line] (5) -- (top);
		\end{tikzpicture}
	\end{center}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=right:{1}] (1) at (1, 1) {};
			\node [bnode, label=left:{2}] (2) at (-1, 1) {};
			\node [bnode, label=right:{3}] (3) at (0, 2) {};
			\node [wnode, label=right:{4}] (4) at (2, 2) {};
			\node [bnode, label=left:{5}] (5) at (-2, 2) {};
			\node [wnode, label=right:{6}] (6) at (2, 3) {};
			\node [bnode, label=right:{}] (7) at (0, 3) {};
			\node [bnode, label={$\top$}] (top) at (0, 4) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (4);
			\path [line] (2) -- (3);
			\path [line] (2) -- (5);
			\path [line] (4) -- (6);
			\path [line] (4) -- (7);
			\path [line] (6) -- (top);
			\path [line] (3) -- (7);
			\path [line] (7) -- (top);
			\path [line] (5) -- (top);
		\end{tikzpicture}
	\end{center}
	\end{minipage}
	\caption{Cas cla\_v7 : première itération}
	\label{clav7_1}
\end{figure}

À ce stade, plusieurs correctifs ont été envisagé. Le premier est de faire une boucle de traitement où on refait tout le processus tant que tous les treillis d'atome ne sont pas disctributif, comme le montre la figure \ref{clav7_2} représentant la seconde itération, c'est la solution utilisé à l'heure actuelle. 

\begin{figure}[H]
	\begin{minipage}{0.5\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=right:{1}] (1) at (1, 1) {};
			\node [wnode, label=left:{2}] (2) at (-1, 1) {};
			\node [wnode, label=right:{3}] (3) at (0, 2) {};
			\node [wnode, label=right:{4}] (4) at (2, 2) {};
			\node [wnode, label=left:{5}] (5) at (-2, 2) {};
			\node [wnode, label=right:{6}] (6) at (2, 3) {};
			\node [bnode, label=right:{}] (7) at (0, 3) {};
			\node [wnode, label={$\top$}] (top) at (0, 4) {};
			\node [bnode, label=left:{}] (8) at (-2, 3) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (4);
			\path [line] (2) -- (3);
			\path [line] (2) -- (5);
			\path [line] (4) -- (6);
			\path [line] (4) -- (7);
			\path [line] (6) -- (top);
			\path [line] (3) -- (7);
			\path [line] (7) -- (top);
			\path [line] (5) -- (8);
			\path [line] (3) -- (8);
			\path [line] (8) -- (top);
		\end{tikzpicture}
	\end{center}
	\end{minipage}
	\begin{minipage}{0.5\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=right:{1}] (1) at (1, 1) {};
			\node [wnode, label=left:{2}] (2) at (-1, 1) {};
			\node [wnode, label=right:{3}] (3) at (0, 2) {};
			\node [wnode, label=right:{4}] (4) at (2, 2) {};
			\node [wnode, label=left:{5}] (5) at (-2, 2) {};
			\node [wnode, label=right:{6}] (6) at (2, 3) {};
			\node [bnode, label=right:{}] (7) at (0, 3) {};
			\node [wnode, label={$\top$}] (top) at (0, 4) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (4);
			\path [line] (2) -- (3);
			\path [line] (2) -- (5);
			\path [line] (4) -- (6);
			\path [line] (4) -- (7);
			\path [line] (6) -- (top);
			\path [line] (3) -- (7);
			\path [line] (7) -- (top);
			\path [line] (5) -- (7);
		\end{tikzpicture}
	\end{center}
	\end{minipage}
	\caption{Cas cla\_v7 : seconde itération}
	\label{clav7_2}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 0.5cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [inout, right = of start] (end) {fin};
			\node [block, below = of start] (import) {importation};
			\node [block, right = of import] (export) {exportation};
			\node [decision, below = of import] (median) {médian ?};
			\node [block, left = of median] (extract) {extraction};
			\node [block, below = of extract] (algo) {algorithme};
			\node [block, below = of algo] (commun) {remise en commun};
			\node [block, right = of commun] (fusion) {fusion};
			% Draw edges
			\path [line2] (start) -- (import);
			\path [line2] (export) -- (end);
			\path [line2] (import) -- (median);
			\path [line2] (median) -- (extract);
			\path [line2] (extract) -- (algo);
			\path [line2] (fusion) -- (median);
			\path [line2] (algo) -- (commun);
			\path [line2] (median) -| (export);
			\path [line2] (commun) -- (fusion);
		\end{tikzpicture}
	\end{center}
	\caption{Worflow de la version du programme incluant la boucle}
	\label{workflow_boucle}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\begin{tikzpicture}[node distance = 0.5cm, auto]
			% Place nodes
			\node [inout] (start) {début};
			\node [block, below = of start] (extract) {extraction};
			\node [algorithm, below = of extract] (eachatom) {pour chaque atome};
			\node [inout, right = of eachatom] (end) {fin};
			\node [block, left = of eachatom] (arrow) {relations flèches};
			\node [algorithm, below = of eachatom] (distributif) {distributif ?};
			% Draw edges
			\path [line2] (start) -- (extract);
			\path [line2] (extract) -- (median);
			\path [line2] (eachatom) -- (arrow);
			\path [line2] (arrow) |- (distributif);
			\path [line2] (distributif) -- (eachatom);
			\path [line2] (eachatom) -- (end);
			\path [line2] (distributif) -| (end);
		\end{tikzpicture}
	\end{center}
	\caption{Sous worflow correspondant au bloque \guillemotleft{} médian ? \guillemotright{}}
	\label{workflow_median}
\end{figure}

\section{Ouvertures}

\subsection{Système de boucle}

Comme nous l'avons vu précédemment, nous devons boucler sur l'algorithme afin de prendre en considération les cas qui générent un nouvel $N_5$ ou $M_3$ lors de leur première résolution. Les méthodes présentées ici ne sont pas utilisées dans le programme mais sont des pistes intéressantes à garder à l'esprit en cas de problèmes futurs.

\smallbreak

Pour la première, il s'agit de faire la fusion pas à pas. On execute la méthode cla différemment. On extrait les contextes des treillis des atomes puis on effectue pour chacun d'eux la transformation en contexte de treillis distributif et on l'assemble avec le contexte global et c'est à ce moment où on fait les fusions si besoin avant de passer au contexte du treillis de l'atome suivant. Cette façon de faire peut permettre de gagner du temps sur la phase de la fusion mais en ferra perdre lors de l'étape de transformation en treillis distributif. Je ne peux pas déterminer laquelle est la meilleure à l'heure actuelle, reste à voir si à l'avenir de nouveaux problèmes se posent et si cette nouvelle méthode peut apporter des réponses.

\smallbreak

La seconde est de faire une boucle sur tout le c\oe ur du processus et de faire les fusions de n\oe uds à la fin. Cette solution contrairement à la première empêche toute possibilité de cycle dû à la fusion mais donne la plupart du temps le treillis distributif maximal pour chaque atome et la fusion devient par conséquent très compliquée, ce qui donne des treillis bien plus grand que ceux visés.

\subsection{Le cas des chaines}

Je ne l'ai pas encore détaillé en dehors du workflow mais le programme effectue également une épuration des chaînes qu'il rencontre lorsque le concept courant n'est pas un concept présent dans le treillis d'origine et qu'il ne possède pas plus de un sup et pas plus de un inf. Nous pouvons résumer les conditions de cette façon :

\paragraph*{Condition d'épuration}
Soit $a$ le n\oe ud qu'on souhaite épurer :
\begin{itemize}
	\item $ a \in J \setminus J_{origine}$
	\item $\forall x_1, x_2 \in J, b, c \in J\\
		\uparrow \! b \not \subset \uparrow \! x_1 \not \subset \uparrow \! a\\
		\uparrow \! a \not \subset \uparrow \! x_2 \not \subset \uparrow \! c$
	\item $\forall y_1, y_2 \in J, b, c \in J\\
		b \neq y_1, c \neq y_2\\
		\uparrow \! b \not \subset \uparrow \! x_1 \not \subset \uparrow \! a\\
		\uparrow \! a \not \subset \uparrow \! x_2 \not \subset \uparrow \! c$
\end{itemize}
{\bf TODO: Trouver notation pour il existe un unique b, c}
\smallbreak

Malheuresement, cette partie n'est pas fiable et résulte principalement d'une intuition basé sur un objectif à atteindre et donnant lieu à un raccourci par rapport à une propriété ou à un traitement non mis à découvert. Ce cas s'est présenté une seule fois jusqu'à présent, sur le cas \guillemotleft{} cla\_v6 \guillemotright{}. L'épuration est effectué au même moment que la fusion. Si on ne l'effectue pas pour ce cas, nous allons boucler et obtenir une solution assez loin de ce qu'on cherche du fait qu'on recommence toute la procédure à cause de la présence d'un $N_5$. C'est sous doute le 1er aspect du programme à garder sous surveillance.

\begin{figure}[H]
	\begin{minipage}{0.3\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [bnode, label=left:{1}] (1) at (-0.5, 1) {};
			\node [bnode, label=right:{2}] (2) at (0.5, 1) {};
			\node [bnode, label=left:{3}] (3) at (-1, 2) {};
			\node [bnode, label=right:{}] (B) at (0, 2) {};
			\node [bnode, label=right:{4}] (4) at (1, 2) {};
			\node [bnode, label=left:{5}] (5) at (-1, 3) {};
			\node [bnode, label=right:{6}] (6) at (1, 3) {};
			\node [wnode, label=left:{7}] (7) at (-1, 4) {};
			\node [bnode, label=left:{}] (F) at (0, 4) {};
			\node [bnode, label={$\top$}] (top) at (0, 5) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (B);
			\path [line] (1) -- (3);
			\path [line] (2) -- (B);
			\path [line] (2) -- (4);
			\path [line] (3) -- (5);
			\path [line] (B) -- (F);
			\path [line] (4) -- (6);
			\path [line] (5) -- (7);
			\path [line] (5) -- (F);
			\path [line] (6) -- (top);
			\path [line] (7) -- (top);
			\path [line] (F) -- (top);
		\end{tikzpicture}
	\end{center}
	\caption{Cas cla\_v6}
	\end{minipage}
	\begin{minipage}{0.3\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=left:{1}] (1) at (-0.5, 1) {};
			\node [wnode, label=right:{2}] (2) at (0.5, 1) {};
			\node [wnode, label=left:{3}] (3) at (-1, 2) {};
			\node [wnode, label=right:{}] (B) at (0, 2) {};
			\node [wnode, label=right:{4}] (4) at (1, 2) {};
			\node [bnode, label=left:{5}] (5) at (-1, 3) {};
			\node [wnode, label=right:{6}] (6) at (1, 3) {};
			\node [bnode, label=left:{7}] (7) at (-1, 4) {};
			\node [bnode, label=left:{}] (F) at (0, 4) {};
			\node [bnode, label={$\top$}] (top) at (0, 6) {};
			\node [wnode, label=right:{}] (G) at (0, 3) {};
			\node [bnode, label=right:{}] (H) at (0, 5) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (B);
			\path [line] (1) -- (3);
			\path [line] (2) -- (B);
			\path [line] (2) -- (4);
			\path [line] (3) -- (5);
			\path [line] (B) -- (G);
			\path [line] (4) -- (6);
			\path [line] (5) -- (7);
			\path [line] (5) -- (F);
			\path [line] (6) -- (F);
			\path [line] (7) -- (top);
			\path [line] (F) -- (H);
			\path [line] (H) -- (top);
			\path [line] (G) -- (F);
			\path [line] (3) -- (G);
			\path [line] (4) -- (G);
		\end{tikzpicture}
	\end{center}
	\caption{Cas cla\_v6, avant épuration}
	\end{minipage}
	\begin{minipage}{0.4\textwidth}
	\begin{center}
		\begin{tikzpicture}
			\node [wnode, label=below:{$\bot$}] (bot) at (0,0) {};
			\node [wnode, label=left:{1}] (1) at (-0.5, 1) {};
			\node [wnode, label=right:{2}] (2) at (0.5, 1) {};
			\node [wnode, label=left:{3}] (3) at (-1, 2) {};
			\node [wnode, label=right:{}] (B) at (0, 2) {};
			\node [wnode, label=right:{4}] (4) at (1, 2) {};
			\node [wnode, label=left:{5}] (5) at (-1, 3) {};
			\node [wnode, label=right:{6}] (6) at (1, 3) {};
			\node [wnode, label=left:{7}] (7) at (-1, 4) {};
			\node [wnode, label=left:{}] (F) at (0, 4) {};
			\node [wnode, label={$\top$}] (top) at (0, 8) {};
			\node [wnode, label=right:{}] (G) at (0, 3) {};
			\node [bnode, label=right:{}] (8) at (0, 5) {};
			\node [bnode, label=right:{}] (9) at (0, 6) {};
			\node [bnode, label=right:{}] (10) at (-0.5, 7) {};
			\node [bnode, label=right:{}] (11) at (0.5, 7) {};
		
			\path [line] (bot) -- (1);
			\path [line] (bot) -- (2);
			\path [line] (1) -- (3);
			\path [line] (1) -- (B);
			\path [line] (1) -- (3);
			\path [line] (2) -- (B);
			\path [line] (2) -- (4);
			\path [line] (3) -- (5);
			\path [line] (B) -- (G);
			\path [line] (4) -- (6);
			\path [line] (5) -- (7);
			\path [line] (5) -- (F);
			\path [line] (6) -- (F);
			\path [line] (7) -- (8);
			\path [line] (F) -- (8);
			\path [line] (G) -- (F);
			\path [line] (3) -- (G);
			\path [line] (4) -- (G);
			\path [line] (8) -- (9);
			\path [line] (9) -- (10);
			\path [line] (9) -- (11);
			\path [line] (10) -- (top);
			\path [line] (11) -- (top);
		\end{tikzpicture}
	\end{center}
	\caption{Cas cla\_v6, sans épuration}
	\end{minipage}
\end{figure}

\subsection{Optimalité du treillis}


\subsection{Optimisation du programme}